#+begin_export latex
\section{Introduction}
The program \ty{alfy} takes as input a table of match lengths and
subject IDs which was constructed with \ty{prepAlfy}. It returns a
four column table consisting of the start and end of the query
coordinates, the measure of homology, and the subject sequence that
region is most similar to. Figure~\ref{fig:alf} shows an output
example of \ty{alfy}.

\section{Implementation}
The outline of \ty{alfy} contains hooks for imports, functions, and
the logic of the main function.
#+end_export
#+begin_src go <<alfy.go>>=
  package main

  import (
	  //<<Imports, Ch. \ref{ch:alf}>>
  )
  //<<Types, Ch. \ref{ch:alf}>>
  func main() {
	  //<<Main function, Ch. \ref{ch:alf}>>
  }
#+end_src
#+begin_export latex
In the main function we prepare the error handling, declare the
options, set the usage, parse the options and calculate the homology
between the queries and the subject files.
#+end_export
#+begin_src go <<Main function, Ch. \ref{ch:alf}>>=
  //<<Prepare error handling, Ch. \ref{ch:alf}>>
  //<<Declare options, Ch. \ref{ch:alf}>>
  //<<Set usage, Ch. \ref{ch:alf}>>
  //<<Parse options, Ch. \ref{ch:alf}>>
  //<<Read intervals file, Ch. \ref{ch:alf}>>
  // <<Iterate over Query and Sequence, Ch. \ref{ch:alf}>>
#+end_src
#+begin_export latex
The error handling is handled by the util function
\ty{PrepareErrorMessages}.
#+end_export
#+begin_src go <<Prepare error handling, Ch. \ref{ch:alf}>>=
  util.PrepareErrorMessages("alfy")
#+end_src
#+begin_export latex
We import \ty{util}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:alf}>>=
  "github.com/evolbioinf/alfy/util"
#+end_src
#+begin_export latex
We declare the options for the version.
#+end_export
#+begin_src go <<Declare options, Ch. \ref{ch:alf}>>=
  optV := flag.Bool("v", false, "version")
  optF := flag.String("f", "", "interval file")
  optW := flag.Int("w", 80, "window length")
#+end_src
#+begin_export latex
We import \ty{flag}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:alf}>>=
"flag"
#+end_src
#+begin_export latex
The usage is split into three parts. The usage message, an explanation
of \ty{alfy} and an example command.
#+end_export
#+begin_src go <<Set usage, Ch. \ref{ch:alf}>>=
  u := "alfy [prepAlfy.out]"
  p := "Calculate homology between queries and subjects."
  e := "alfy alfy.in"
  clio.Usage(u, p, e)
#+end_src
#+begin_export latex
We import \ty{clio}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:alf}>>=
"github.com/evolbioinf/clio"
#+end_src
#+begin_export latex
We parse the options and respond to the version option, -v and the
interval file, -f.
#+end_export
#+begin_src go <<Parse options, Ch. \ref{ch:alf}>>=
  flag.Parse()
  //<<Respond to -v, Ch. \ref{ch:alf}>>
  //<<Respond to -f, Ch. \ref{ch:alf}>>
#+end_src
#+begin_export latex
If the user requested the version, we call the utility function
\ty{Version} with the program name.
#+end_export
#+begin_src go <<Respond to -v, Ch. \ref{ch:alf}>>=
  if *optV {
	  util.Version("alfy")
  }
#+end_src
#+begin_export latex
If the user did not set an interval file, we exit with a friendly
message.
#+end_export
#+begin_src go <<Respond to -f, Ch. \ref{ch:alf}>>=
  if *optF == "" {
	  m := "please provide the intervals file " +
		  "(prepAlfy output)"
	  fmt.Fprintf(os.Stderr, "%s\n",m)
	  os.Exit(1)
  }
#+end_src
#+begin_export latex
We then read the interval files, defer its closure and parse its
header and content. The parsed file is saved in the queries variable
which contains the data from all queries, sequences and intervals that
have been read.
#+end_export
#+begin_src go <<Read intervals file, Ch. \ref{ch:alf}>>=
  file, err := os.Open(*optF)
  util.Check(err)
  defer file.Close()
  queries := []*Query{}
  //<<Parse Input file, Ch. \ref{ch:alf}>>
#+end_src
#+begin_export latex
We import \ty{os} and \ty{fmt}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:alf}>>=
  "os"
  "fmt"
#+end_src
#+begin_export latex
To parse the input file, we start by initializing the variable queries
of the type Query. We construct the bufio reader, initialize the
remaining variables and start to parse the document. We skip empty
lines, and parse the two types of headers and the intervals. The
interval files contains two type of headers. The main header, which
starts with a \#, and denotes the start of a query, a secondary
header, starting with $>$, denoting the start of a sequence and the
intervals describing the location of the exact matches and the
annotation of the subject IDs.
#+end_export
#+begin_src go <<Parse Input file, Ch. \ref{ch:alf}>>=
  //<<New Query, Sequence and Interval, Ch.\ref{ch:alf}>>
  sc := bufio.NewScanner(file)
  for sc.Scan() {
	  line := sc.Text()
	  //<<Skip empty lines, Ch. \ref{ch:alf}>>
	  if line[0] =='#' {
		  //<<Deal with query header, Ch. \ref{ch:alf}>>
	  } else if line[0] == '>' {
		  //<<Deal with sequence header, Ch. \ref{ch:alf}>>
	  } else {
		  //<<Deal with intervals, Ch. \ref{ch:alf}>>
	  }
  }
#+end_src
#+begin_export latex
We import \ty{bufio}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:alf}>>=
  "bufio"
#+end_src
#+begin_export latex
To conveniently handle the input we create three structure types:
query, sequence and intervals.
#+end_export
#+begin_src go<<Types, Ch. \ref{ch:alf}>>=
  //<<Query file structure, Ch. \ref{ch:alf}>>
  //<<Sequence structure, Ch. \ref{ch:alf}>>
  //<<Interval structure, Ch. \ref{ch:alf}>>
#+end_src
#+begin_export latex
A query has a name and is made up of one or more sequences.
#+end_export
#+begin_src go <<Query file structure, Ch. \ref{ch:alf}>>=
  type Query struct {
	  name string
	  sequences []*Sequence
  }
#+end_src
#+begin_export latex
A sequence in turn, contains a header with the name of the sequence,
its length, and the map between the subject IDs and the subject
sequence names. It is followed by the table of intervals.
#+end_export
#+begin_src go <<Sequence structure, Ch. \ref{ch:alf}>>=
  type Sequence struct {
	  name  string
	  length int
	  subjectNames map[int]string
	  intervals []*Interval
  }
#+end_src
#+begin_export latex
The table of intervals describing the exact matches between the
various subject IDs and each given query sequence are contained in the
Intervals structure type. This contains the start and end of each
interval, the match length at the first position of the interval, and
one or more subject IDs where the exact match was found.
#+end_export
#+begin_src go <<Interval structure, Ch. \ref{ch:alf}>>=
  type Interval struct {
	  start int
	  end int
	  ml int
	  subjectIDs []int
  }
#+end_src
#+begin_export latex
Before parsing the data we create a new Query, Sequence and
Interval. The parsed data will then be appended each of these three
variables.
#+end_export
#+begin_src go <<New Query, Sequence and Interval, Ch.\ref{ch:alf}>>=
  var query *Query
  var sequence *Sequence
  var interval *Interval
#+end_src
#+begin_export latex
We start parsing the file by skipping empty lines.
#+end_export
#+begin_src go <<Skip empty lines, Ch. \ref{ch:alf}>>=
  if len(line) == 0 {
	  continue
  }
#+end_src
#+begin_export latex
Then we deal with the query headers which start with a \# followed by
the query name with no blanks in between. We create a new Query and
set its name as the entire string except the first character which
marks the start of the header. We then append the new query to the
array of all queries.
#+end_export
#+begin_src go <<Deal with query header, Ch. \ref{ch:alf}>>=
  query = new(Query)
  query.name = line[1:]
  queries = append(queries, query)
#+end_src
#+begin_export latex
Inside the query, there are one or more sequences. If the line starts
with a $>$, we create a new sequence and split the line into its
fields. The first two fields corresponds to the sequence name and its
length. The sequence name is a string, so it can be extracted
directly. However to extract the sequence length we need to convert it
to an integer and check for errors. We map the numerical IDs and names
to each other. At the end, we append the sequence to the list of query
sequences.
#+end_export
#+begin_src go <<Deal with sequence header, Ch. \ref{ch:alf}>>=
  var err error
  sequence = new(Sequence)
  fields := strings.Fields(line)
  sequence.name = fields[0][1:]
  sequence.length, err = strconv.Atoi(fields[1])
  if err != nil {
	  log.Fatalf("%q is not a number", fields[1])
  }
  //<<Map subject names to IDs, Ch. \ref{ch:alf}>>
  query.sequences = append(query.sequences, sequence)
#+end_src
#+begin_export latex
We import \ty{log}, \ty{strings} and \ty{strconv}.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:alf}>>=
  "log"
  "strings"
  "strconv"
#+end_src
#+begin_export latex
To map the subject names and subject IDs we start by checking if the
map is nill. If yes, we construct one. Then we iterate over all
remaining fields and split them into keys, the subject IDs, and
values, the subject names. We add the new pair to the set of subject
names in the sequence.
#+end_export
#+begin_src go <<Map subject names to IDs, Ch. \ref{ch:alf}>>=
  if sequence.subjectNames == nil {
	  sequence.subjectNames = make(map[int]string)
  }
  for i := 2 ; i < len(fields); i++ {
	  arr := strings.Split(fields[i],"=")
	  k, err := strconv.Atoi(arr[0])
	  if err != nil {
		  log.Fatalf("%q is not a number",
			  arr[0])
	  }
	  sequence.subjectNames[k-1] = arr[1]
  }
#+end_src
#+begin_export latex
After parsing the headers, we parse the table of intervals. We start
by creating a new interval. Each row of intervals consists of four
numerical columns. We extract the start, end and match length of each
interval. We convert the string into an integer and check for
errors. After parsing the slice of annotated subject IDs, we append
the new interval to the list of sequence intervals.
#+end_export
#+begin_src go <<Deal with intervals, Ch. \ref{ch:alf}>>=
  var err error
  interval = new(Interval)
  fields := strings.Fields(line)
  interval.start, err = strconv.Atoi(fields[0])
  if err != nil {
	  log.Fatalf("%q is not a number",
		  fields[0])
  }
  interval.end, err = strconv.Atoi(fields[1])
  if err != nil {
	  log.Fatalf("%q is not a number",
		  fields[1])
  }
  interval.ml, err = strconv.Atoi(fields[2])
  if err != nil {
	  log.Fatalf("%q is not a number",
		  fields[2])
  }
  //<<Parse annotated subjects, Ch. \ref{ch:alf}>>
  sequence.intervals = append(sequence.intervals,
	  interval)
#+end_src
#+begin_export latex
Each interval may contain one or more annotated subject IDs. Since
subject IDs are delimited by commas, we split the last field by commas
and then iterate over each of the obtained fields. For each subject
ID, we convert it into an integer, check for errors and append it to
the subject IDs of the interval.
#+end_export
#+begin_src go <<Parse annotated subjects, Ch. \ref{ch:alf}>>=
  arr := strings.Split(fields[3],",")
  for i := 0; i< len(arr); i++ {
	  x, err := strconv.Atoi(arr[i])
	  if err != nil {
		  log.Fatalf("%q is not a number ", arr[i])
	  }
	  interval.subjectIDs =
		  append(interval.subjectIDs, x-1)
  }
#+end_src
#+begin_export latex
\subsection{Score the intervals}
We score the intervals for each query and sequence independently. The
scoring of the intervals is done independently for each query and
sequence. The subject IDs intervals are scored by summing up the match
lengths at every position inside a given window of length $w$. The one
or more subjects IDs with the highest scores are considered to be the
window winner and writen down. Before the sliding window analysis we
unfold the list of parsed intervals into a matrix of match
lengths. Then the matrix can be scored and the maximum score picked.
#+end_export
#+begin_src go <<Iterate over Query and Sequence, Ch. \ref{ch:alf}>>=
  for _, query := range queries {
	  for _, sequence := range query.sequences {
		  //<<Unfold match length intervals, Ch. \ref{ch:alf}>>
		  //<<Score intervals, Ch. \ref{ch:alf}>>
		  //<<Get maximum window score, Ch. \ref{ch:alf}>>
		  //<<Merge adjacent windows, Ch. \ref{ch:alf}>>
  		  //<<Prepare output table, Ch. \ref{ch:alf}>>
	  }
  }
#+end_src
#+begin_export latex
To unfold the list of intervals, we first initialize our matrix,
matches, which will contain all matches and then fill it.
#+end_export
#+begin_src go <<Unfold match length intervals, Ch. \ref{ch:alf}>>=
  //<<Create match length matrix, Ch. \ref{ch:alf}>>
  //<<Fill match length matrix, Ch. \ref{ch:alf}>>
#+end_src
#+begin_export latex
The matches matrix is an $m$ by $n$ matrix, where $m$ is the number of
annotated subject IDs and $n$ the length of the query.
#+end_export
#+begin_src go <<Create match length matrix, Ch. \ref{ch:alf}>>=
  m :=  len(sequence.subjectNames)
  n := sequence.length
  matches := make([][]int,m)
  for i := range sequence.subjectNames {
	  matches[i] = make([]int,n)
  }
#+end_src
#+begin_export latex
After initializing the matrix, it is filled with the match lengths
previously parsed. For every interval, we iterate from the beginning
of the match, until the end of the match, given by the starting
position plus the length of the match minus 1. To count the number of
positions we declare a counter $p$. For every position we move to the
right, we increase the counter by one and decrease the match length by
the respective number of positions we have walked so far.

Because each interval may contain several annotations, we also iterate
over all annotated subject IDs for a given interval. This allows us to
save the correct match length in the respective subjectID slice.

Finally, overwrite existing match lengths, if they are smaller than
the incoming match length. Because we are extrapolating match lengths
across the full match, we only care about the greatest one.
#+end_export
#+begin_src go <<Fill match length matrix, Ch. \ref{ch:alf}>>=
  for _, interval := range sequence.intervals {
	  for _, i := range interval.subjectIDs {
		  p := 0
		  start := interval.start
		  end := interval.start+interval.ml-1
		  for j := start ; j<= end; j++ {
			  curr := interval.ml -p
			  if curr > matches[i][j] {
				  matches[i][j] = curr
			  }
			  p++
		  }
	  }
  }
#+end_src
#+begin_export latex
The scoring of the subject IDs is done with a sliding window
analysis. Where for every position, p, within the window w, we sum the
match lengths of the subject ID at all positions. We start by
initializing a two-dimensional score array to hold the summed match
lengths at a given window for each subject ID. Then we iterate over
the length of the sequence, and if is longer than the choosen window,
we start the sliding analysis.
#+end_export
#+begin_src go <<Score intervals, Ch. \ref{ch:alf}>>=
  score := make([][]int,len(sequence.subjectNames))
  for i := range matches {
	  if len(matches[i]) >= *optW {
		  //<<Open first window, Ch. \ref{ch:alf}>>
	  }
  }
#+end_src
#+begin_export latex
For the first window, we set the left and the right border and the
current match score to zero. Then we walk along the matches until we
reach the end of the first sliding window. For each position we sum
the existing match length for each subject ID and step by 1
position. After reaching the end of the first window, we store the
summed match lengths and slide the window.
#+end_export
#+begin_src go <<Open first window, Ch. \ref{ch:alf}>>=
  l := 0
  r := 0
  match := 0
  for r < *optW {
	  match = match + matches[i][r]
	  r++
  }
  //<<Store window score, Ch. \ref{ch:alf}>>
  //<<Slide window, Ch. \ref{ch:alf}>>
#+end_src
#+begin_export latex
To store the window score we append the final match length to the
score array, and reset the current match to zero.
#+end_export
#+begin_src go <<Store window score, Ch. \ref{ch:alf}>>=
  score[i] = append(score[i],match)
  match = 0
#+end_src
#+begin_export latex
To slide the window, we iterate over the length of the sequence, and
move both the left and right border by one, since the first window is
already done. Then, we sum the match lengths for each subject ID
between the left and the right border of the new window
interval. After running across the entire sequence, we store the
summed match lengths.
#+end_export
#+begin_src go <<Slide window, Ch. \ref{ch:alf}>>=
  for r < len(matches[i]) {
	  l++
	  r++
	  for j := l; j < r ;j++ {
		  match = match + matches[i][j]
	  }
	  //<<Store window score, Ch. \ref{ch:alf}>>
  }
#+end_src
#+begin_export latex
After the sliding window analysis is complete, we summarize the
results by extracting the maximum score found per window and the
respective subject ID. We initialize two variables, one to store the
maximum score found per window, the second to store the corresponding
subject ID.

Then, for the length of the number of windows analyzed, we iterate
over the existing subject IDs and save the maximum summed match length
found and its respective subject ID. Since this analysis is done
across the same sequence, every subject ID has the same number of
calculated windows.
#+end_export
#+begin_src go <<Get maximum window score, Ch. \ref{ch:alf}>>=
  maxScore := make([]int,0)
  maxSbjct := make([][]int,0)
  for j := 0; j < len(score[0]); j++ {
	  max := -1
	  var ms []int
	  for i := 0; i < m ; i++{
		  if max < score[i][j] {
			  max = score[i][j]
			  ms = ms[:0]
			  ms = append(ms,i)
		  } else if max == score[i][j] {
			  ms = append(ms,i)
		  }
	  }
	  maxScore = append(maxScore,max)
	  maxSbjct = append(maxSbjct,ms)
	  ms = ms[:0]
  }
#+end_src
#+begin_export latex
The next step is to merge adjacent windows that share the same
annotation.

\subsection{Merge adjacent windows}

Adjacent windows that share the same annotation may be merged into a
larger single window. For this, we need to keep track of the left and
right borders of each window, the annotations as well as two types of
scores, the sum of the window score and the score per bp. We start by
constructing a structure type window, which will contain all of these
variables.
#+end_export
#+begin_src go <<Types, Ch. \ref{ch:alf}>>=
  type Window struct{
	  start int
	  end int
	  score int
	  sbp float64
	  ID []int
  }
#+end_src
#+begin_export latex
To check for adjacent windows, we start by initializing the window
type variable. Then we iterate over the length of the maxSbjct, which
corresponds to the total number of sliding windows that were analyzed.
We initialize all variables required for keeping track of the window
borders and respective scores. The left border is to be tracked by
variable $p$, and the score by variables. First, we check if we have
reached the end of the sequence, if so we store the last
window. Otherwise, we compare the annotation of the current window
with the next one.
#+end_export
#+begin_src go <<Merge adjacent windows, Ch. \ref{ch:alf}>>=
  windows := []*Window{}
  var window *Window
  p := 0
  s :=0 
  for i := 0; i < len(maxSbjct); i++{
	  //<<Initialize window variables, Ch. \ref{ch:alf}>>
	  if i+1 >= len(maxSbjct) {
		  //<<Close last window, Ch. \ref{ch:alf}>>
	  } else {
		  //<<Check annotation of next window, Ch. \ref{ch:alf}>>
	  }
  }
#+end_src
#+begin_export latex
For each window we initialize the right border and the current subject
IDs. Since the sliding window analysis is done by sliding one step to
the right, we know that the right border of the nth window, starts $n$
positions to the right of the window length variable.

The slice of IDs of each window corresponds to the slices stored in
the maxSbjct variable. We also assign the current slice of IDs to the
variable current.
#+end_export
#+begin_src go <<Initialize window variables, Ch. \ref{ch:alf}>>=
  window = new(Window)
  window.end = *optW + i
  window.ID = maxSbjct[i]
  curr := window.ID
#+end_src
#+begin_export latex
If the right border corresponds to the length of the sequence we have
reached the end of the sliding window analysis. We update the left
border of the window, and its existing score. Since so far we have
been dealing with integers we need to convert these to floats. After
calculating the score per base pair, we append the last window to the
slice of closed windows and break out of the loop.
#+end_export
#+begin_src go <<Close last window, Ch. \ref{ch:alf}>>=
  window.start = p
  window.score = s + maxScore[i]
  window.sbp = float64(window.score)/
	  (float64(window.end)-
		  float64(window.start))
  windows = append(windows,window)
  break
#+end_src
#+begin_export latex
If we have yet to reach the end, we set variable set to store the
slice of subjectIDs of the next window. If the slices of the current
and the following window are identical the window can be extended,
otherwise we close it.
#+end_export
#+begin_src go <<Check annotation of next window, Ch. \ref{ch:alf}>>=
  next :=maxSbjct[i+1]
  if slices.Equal(curr,next) {
	  //<<Extend window, Ch. \ref{ch:alf}>>
  } else {
	  //<<Close window, Ch. \ref{ch:alf}>>
  }
#+end_src
#+begin_export latex
We import \ty{slices} to compare the slices of subject IDs.
#+end_export
#+begin_src go <<Imports, Ch. \ref{ch:alf}>>=
  "slices"
#+end_src
#+begin_export latex
To extend the window, we extend the right border by one position, and
update the score of the window.
#+end_export
#+begin_src go <<Extend window, Ch. \ref{ch:alf}>>=
  window.end = i + *optW +1
  s = s + maxScore[i]
#+end_src
#+begin_export latex
If the subject IDs are not identical we close the current window. We
store the right border of the window, the summed up score and the
score per base pair. We then append the results to the array of
previously saved windows and break out of the loop. The left border of
the window is given by the variable $p$. After appending the current
window to the slice of closed windows, we update the left border of
the new window, and set the current window score to 0.
#+end_export
#+begin_src go <<Close window, Ch. \ref{ch:alf}>>=
  window.score = window.score
  window.end = i + * optW
  window.start = p
  window.score = s + maxScore[i]
  window.sbp = float64(window.score)/
	  (float64(window.end)-float64(window.start))
  windows = append(windows,window)
  p = i +1
  s = 0
#+end_src
#+begin_export latex
After merging adjacent windows, we print the stored windows. We start
by printing the header. For easier readability, instead of printing
the subject IDs, we directly print the subject names. Then, we print
the summary of the intervals.
#+end_export
#+begin_src go <<Prepare output table, Ch. \ref{ch:alf}>>=
  fmt.Printf("#Query %s\n>Sequence: %s\n",
	  query.name,sequence.name)
  for _,win := range windows {
	  //<<Convert numeric IDs to names, Ch. \ref{ch:alf}>>
	  //<<Print intervals, Ch. \ref{ch:alf}>>
  }
#+end_src
#+begin_export latex
To convert the numeric IDs to the subject names, we iterate over the
slice of IDs, and then for each value extract the corresponding
subject Name saved in the subjectNames map previously
constructed. Then we remove the extension of the subject file, and
save the slice of converted names.
#+end_export
#+begin_src go <<Convert numeric IDs to names, Ch. \ref{ch:alf}>>=
  str := make([]string, len(win.ID))
  for i, val := range win.ID {
	  name := strconv.Itoa(val)
	  name = sequence.subjectNames[val]
	  //<<Clean subject name extension, Ch. \ref{ch:alf}>>
	  str[i] = fmt.Sprintf("%v", name)
  }
#+end_src
#+begin_export latex
To remove the extension of the filenames, we just obtain the index of
the last substring, delimited by a dot, and slice the string up to
that point.
#+end_export
#+begin_src go <<Clean subject name extension, Ch. \ref{ch:alf}>>=
  e := strings.LastIndex(name, ".")
  name = name[:e]
#+end_src
#+begin_export latex
To print the intervals we just iterate through the list of stored
windows. Then we print the left and right borders, the cumulative
match length score, the score per base pair and the slice of subject
IDs separated by comma.
#+end_export
#+begin_src go <<Print intervals, Ch. \ref{ch:alf}>>=
  fmt.Printf("%d\t%d\t%d\t%.3f\t%v\n",
	  win.start, win.end, win.score,
	  win.sbp, strings.Join(str,","))
#+end_src
#+begin_export latex
\section{Testing}

We have now finished writing alfy, and move on to testing it. The
program to test alfy has hooks for imports and the testing logic.
#+end_export
#+begin_src go <<alfy_test.go>>=
  package main

  import(
	  //<<Testing imports, Ch. \ref{ch:alf}>>
  )

  func TestAlfy(t *testing.T) {
	  //<<Testing, Ch. \ref{ch:alf}>>
  }
#+end_src
#+begin_export latex
We import \ty{testing}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:alf}>>=
"testing"
#+end_src
#+begin_export latex
We construct a set of tests, and iterate over them.
#+end_export
#+begin_src go <<Testing, Ch. \ref{ch:alf}>>=
  var tests []*exec.Cmd
  //<<Construct tests, Ch. \ref{ch:alf}>>
  for i, test := range tests {
	  //<<Run test, Ch. \ref{ch:alf}>>
  }
#+end_src
#+begin_export latex
We import \ty{exec}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:alf}>>=
"os/exec"
#+end_src
#+begin_export latex
In the first test, we run alfy a window size of 5, half the length of
the test sequence.
#+end_export
#+begin_src go <<Construct tests, Ch. \ref{ch:alf}>>=
  p := "./alfy"
  f := "prep.out"
  w := "5"
  test := exec.Command(p, "-f", f, "-w", w)
  tests = append(tests, test)
#+end_src
#+begin_export latex
In the second test, we test with a window size of 10, the length of
the testing sequence.
#+end_export
#+begin_src go <<Construct tests, Ch. \ref{ch:alf}>>=
  w = "10"
  test = exec.Command(p, "-f", f, "-w", w)
  tests = append(tests, test)
#+end_src
#+begin_export latex
When running a test, we compare the output we get with the one we
want, which is stored in the files r1.txt and r2.txt.
#+end_export
#+begin_src go <<Run test, Ch. \ref{ch:alf}>>=
  //<<Read test output, Ch. \ref{ch:alf}>>
  //<<Read test input, Ch. \ref{ch:alf}>>
  if !bytes.Equal(get, want) {
	  t.Errorf("get:\n%s\nwant:\n%s\n", get, want)
  }
#+end_src
#+begin_export latex
We import \ty{bytes}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:alf}>>=
"bytes"
#+end_src
#+begin_export latex
We read the output from \ty{alfy}.
#+end_export
#+begin_src go <<Read test output, Ch. \ref{ch:alf}>>=
  get, err := test.Output()
  if err != nil {
	  t.Error(err)
  }
#+end_src
#+begin_export latex
We read the content of the results files, r\*.txt.
#+end_export
#+begin_src go <<Read test input, Ch. \ref{ch:alf}>>=
  r := "r" + strconv.Itoa(i+1) + ".txt"
  want, err := os.ReadFile(r)
  if err != nil {
	  t.Error(err)
  }
#+end_src
#+begin_export latex
We import \ty{strconv} and \ty{os}.
#+end_export
#+begin_src go <<Testing imports, Ch. \ref{ch:alf}>>=
"strconv"
"os"
#+end_src
