
#+begin_export latex
\section{Implementation}
!Package \ty{mat} implements the matching procedure of \ty{alfy}.

Our outline of \ty{mat} contains hooks for imports and functions.
\bpa{mat}{pa:mat}
#+end_export
#+begin_src go <<mat.go>>=
  package mat
  import (
	  <<Imports, Pa. \ref{pa:mat}>>
  )

  <<Functions, Pa. \ref{pa:mat}>>
#+end_src
#+begin_export latex
\epa

!The function \ty{GetMatchLengths} takes as arguments a query
!sequence, the enhanced suffix array (ESA) of a subject sequence, the
!label of that subject sequence, an array of match lengths, a double
!array of subject labels, and whether or not the query is a reverse
!strand. It then updates the arrays of match lengths and subject
!labels.

As described in Algorithm~\ref{alg:alf}, we initialize the query
position, $j$, to the leftmost position in the query sequence (line
3). We then create two arrays to store match lengths and subject
IDs. Afterwards we calculate the match lengths and rely in two other
functions, \ty{Update} and \ty{Interpolate} to update the matches and
interpolate them.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:mat}>>=
  func GetMatchLengths(q []byte, s *esa.Esa, i int,
	  ml []int, su [][]int, rev bool) {
	  j := 0
	  //<<Create storing arrays for ml and su, Pa. \ref{pa:mat}>>
	  //<<Calculate match lengths, Pa. \ref{pa:mat}>>
	  Update(ml, dml, su, dsu)
	  Interpolate(ml, su) 
  }
#+end_src
#+begin_export latex
We import \ty{esa}.
#+end_export
#+begin_src go <<Imports, Pa. \ref{pa:mat}>>=
  "github.com/evolbioinf/esa"
#+end_src
#+begin_export latex
The storing arrays are two replicas of the matches lenghts and
subjects IDs arrays that was given as input to
\ty{GetMatchesLengths}. These two arrays have the same dimensions but
are initially empty. They will hold the initial match lengths and
respective subject IDs.
#+end_export
#+begin_src go <<Create storing arrays for ml and su, Pa. \ref{pa:mat}>>=
  dml := make([]int, len(ml))
  dsu := make([][]int, len(su))
  for x := range dsu {
      dsu[x] = make([]int,len(su[x]))
  }
#+end_src
#+begin_export latex
In the while loop of Algorithm~\ref{alg:alf}, we first determine the
length, $\ell$, of the longest match of the prefix of $q[j...]$ in
$s$. If we are dealing with a reverse strand, we map the position of
this match to the forward strand. Finally, we move the query position,
$j$, just beyond the terminal mismatch. The matches are saved in the
mirrored arrays.
#+end_export
#+begin_src go <<Calculate match lengths, Pa. \ref{pa:mat}>>=
  m := len(q)
  for j < m {
	  l := s.MatchPref(q[j:]).L
	  p := j
	  if rev {
		  //<<Map to forward strand, Pa. \ref{pa:mat}>>
	  }
	  dml[p] = l
	  dsu[p][0] = i
	  j += l + 1
  }
#+end_src
#+begin_export latex
For our query of length $m$, position $r$ on the reverse strand is
position $f=m-r-1$ on the forward strand. For our match of length
$\ell$ this position on the forward strand is further offset to the
left by $\ell-1$ or nothing, whichever is greater,
$o=\mbox{max}(\ell-1,0)$.
#+end_export
#+begin_src go <<Map to forward strand, Pa. \ref{pa:mat}>>=
  o := l - 1
  if o < 0 {
	  o = 0
  }
  p = m - p - 1 - o
#+end_src
#+begin_export latex
We then update the length of the matches with the function
\ty{Update}. The function \ty{Update} takes as input four arrays: two
arrays for match lengths and two arrays for subject IDs. Two arrays,
ml and su, will store the results from the function, while the other
two arrays, dml and dsu, contain the values to be updated. This
function corresponds to the while loop of Algorithm~\ref{alg:alf}. We
check if the arrays need to be updated, and at the end skip to the end
of the match plus one.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:mat}>>=
  func Update(ml, dml []int, su, dsu [][]int){
	  p := 0
	  for p < len(ml) {
		  //<<Update match length?, Pa. \ref{pa:mat}>>
		  p++
	  }
  }
#+end_src
#+begin_export latex
If the match in the data array, $\mbox{dml}{j}$, is greater than
$\mbox{ml}[j]$, we update $\mbox{ml}[j]$ and note the label of the
current subject sequence, $dsu[j][0]$. If $\mbox{dml}{j}$ is equal to
$\mbox{ml}[j]$ we are looking at a new interval with the same
length. If the subject ID is identical we store the current subject
and drop other subjects present in the slice. If the subject ID is
different we append to it.
#+end_export
#+begin_src go <<Update match length?, Pa. \ref{pa:mat}>>=
  if dml[p] > ml[p] {
	  ml[p] = dml[p]
	  su[p] = su[p][:0]
	  su[p] = append(su[p], dsu[p]...)
  } else if dml[p] == ml[p] {
	  if su[p][0] == dsu[p][0] {
		  ml[p] = dml[p]
		  su[p][0] = dsu[p][0]
		  su[p] = su[p][:1]
	  } else {
		  su[p] = append(su[p], dsu[p][0])
	  }
  }
#+end_src
#+begin_export latex
Function\ty{Interpolate} interpolates the match lengths and subject
labels according to Algorithm~\ref{alg:int}. It takes as input an
updated array of match lengths and subjects IDs. For each position of
the match lengths arrays, we compare the previous to the current match
length.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:mat}>>=
  func Interpolate(ml []int, su [][]int) {
	  for i := 1; i < len(ml); i++ {
		  prev := ml[i-1] - 1
		  curr := ml[i]
		  if prev < 0 {
			  prev = 0
		  }
		  //<<Compare previous and current match, Pa. \ref{pa:mat}>> 
	  }
  }
#+end_src
#+begin_export latex
If the previous match length is larger than the current one, we extend
the match and store the subject IDs corresponding to the extended
match. Else, if the current and the previous match length are
identical we update the subject IDs to include potential new subject
IDs.
#+end_export
#+begin_src go <<Compare previous and current match, Pa. \ref{pa:mat}>>=
   if prev > curr {
	   //<<Store su[i-1] in su[i], Pa. \ref{pa:mat}>>
   } else if prev == curr {
	   //<<Merge su[i] and su[i-1], Pa. \ref{pa:mat}>>
   }
#+end_src
#+begin_export latex
If we are extending the previous match we set the current match length
to the previous one, and add the subject ID to the first position of
the subject ID slice. Then we append the current subject ID to the
slice of existing IDs from the previous position.
#+end_export 
#+begin_src go <<Store su[i-1] in su[i], Pa. \ref{pa:mat}>>=
  ml[i] = prev
  su[i] = su[i][:0]
  su[i] = append(su[i],su[i-1]...)
#+end_src
#+begin_export latex
To merge the subjects IDs, we go through the list of all existing
subject IDs at that position and add to it if the new subject ID is
not contained in the list of subject IDs.

At the end we ensure that the slice only contains the new subject IDs
by reslicing the slice, and the append the new subjectIDs to the ones
that are passed on from the match extension.
#+end_export
#+begin_src go <<Merge su[i] and su[i-1], Pa. \ref{pa:mat}>>=
  c := 0
  for z := 0; z < len(su[i]); z++ {
	  if !(slices.Contains(su[i-1], su[i][z])) {
		  su[i][c] = su[i][z]
		  c++
	  }
  }
  su[i] = su[i][:c]
  su[i] = append(su[i],su[i-1]...)
#+end_src
#+begin_export latex
We import slices.
#+end_export
#+begin_src go <<Imports, Pa. \ref{pa:mat}>>=
"slices"
#+end_src
#+begin_export latex
We've finished writing package \ty{mat}, let's test it.
\section{Testing}
The outline of our testing code contains hooks for imports, functions,
and the testing logic.
#+end_export
#+begin_src go <<mat_test.go>>=
  package mat

  import (
	  //<<Testing imports, Pa. \ref{pa:mat}>>
  )

  //<<Testing functions, Pa. \ref{pa:mat}>>
  func TestMat(t *testing.T) {
	  //<<Testing, Pa. \ref{pa:mat}>>
  }
#+end_src
#+begin_export latex
We import \ty{testing}.
#+end_export
#+begin_src go <<Testing imports, Pa. \ref{pa:mat}>>=
  "testing"
#+end_src
#+begin_export latex
We test the analysis of forward and reverse strands separately.
#+end_export
#+begin_src go <<Testing, Pa. \ref{pa:mat}>>=
  //<<Test analysis of forward strand, Pa. \ref{pa:mat}>>
  //<<Test analysis of reverse strand, Pa. \ref{pa:mat}>>
#+end_src
#+begin_export latex
We construct the forward queries and subjects and the corresponding
expected results. The difference between the analysis of forward and
reverse strands is just a boolean variable, \ty{rev}. We set that to
false before we compare queries and subjects to do the actual testing.
#+end_export
#+begin_src go <<Test analysis of forward strand, Pa. \ref{pa:mat}>>=
  //<<Construct forward queries, Pa. \ref{pa:mat}>>
  //<<Construct forward subjects, Pa. \ref{pa:mat}>>
  //<<Construct wanted results, Pa. \ref{pa:mat}>>
  rev := false
  //<<Compare queries and subjects, Pa. \ref{pa:mat}>>
#+end_src
#+begin_export latex
We take the queries used in Chapter~\ref{ch:int}.
#+end_export
#+begin_src go <<Construct forward queries, Pa. \ref{pa:mat}>>=
  queries := [][]byte{
	  []byte("AAATAATAGT"),
	  []byte("AAATAGTATT")}
#+end_src
#+begin_export latex
We also take the subjects from Chapter~\ref{ch:int}.
#+end_export
#+begin_src go <<Construct forward subjects, Pa. \ref{pa:mat}>>=
  subjects := [][]byte{
	  []byte("AATTTAAATT"),
	  []byte("TAATAATATT")}
#+end_src
#+begin_export latex
We construct the match lengths and the subject labels we want.
#+end_export
#+begin_src go <<Construct wanted results, Pa. \ref{pa:mat}>>=
  wml := [][]int{
	  []int{4,3,2,5,4,3,2,1,0,1},
	  []int{4,3,2,2,1,0,4,3,2,1}}
  wsu := [][][]int{
	  [][]int{{0}, {0}, {0}, {1}, {1},
		  {1}, {1}, {1}, {0,1}, {0,1}},
	  [][]int{{0}, {0}, {0}, {1}, {1},
		  {0,1}, {1}, {1}, {1}, {0,1}}}
#+end_src
#+begin_export latex
For each query we prepare an array of match lengths and an array of
subject labels. Then we iterate over the subjects and check the
match lengths and subject labels we get from that iteration.
#+end_export
#+begin_src go <<Compare queries and subjects, Pa. \ref{pa:mat}>>=
  for i, q := range queries {
	  //<<Prepare $\mbox{ml}$ and $\mbox{su}$, Pa. \ref{pa:mat}>>
	  //<<Iterate over subjects, Pa. \ref{pa:mat}>>
	  //<<Check $\mbox{ml}$ and $\mbox{su}$, Pa. \ref{pa:mat}>>
  }
#+end_src
#+begin_export latex
We create a new pair of arrays to hold the match lengths and the
subject labels for each query position. Since zero is a legitimate
value for match lengths and subject labels, we initialize both arrays
to -1. This allows us to check for gaps in our analysis.
#+end_export
#+begin_src go <<Prepare $\mbox{ml}$ and $\mbox{su}$, Pa. \ref{pa:mat}>>=
  n := len(q)
  ml := make([]int, n)
  su := make([][]int, n)
  for j := 0; j < n; j++ {
	  ml[j] = -1
	  su[j] = append(su[j],-1)
  }
#+end_src
#+begin_export latex
We convert each subject to its enhanced suffix array and update the
match lengths accordingly.
#+end_export
#+begin_src go <<Iterate over subjects, Pa. \ref{pa:mat}>>=
  for j, subject := range subjects {
	  s := esa.MakeEsa(subject)
	  GetMatchLengths(q, s, j, ml, su, rev)
  }
#+end_src
#+begin_export latex
We import \ty{esa}.
#+end_export
#+begin_src go <<Testing imports, Pa. \ref{pa:mat}>>=
  "github.com/evolbioinf/esa"
#+end_src
#+begin_export latex
We check the updated arrays by calling the function \ty{checkM} to
check the match lenghts and \ty{checkS} to check the subject IDs.
#+end_export
#+begin_src go <<Check $\mbox{ml}$ and $\mbox{su}$, Pa. \ref{pa:mat}>>=
  checkM(t, ml, wml[i])
  checkS(t, su, wsu[i])
#+end_src
#+begin_export latex
The function \ty{checkM} compares the array of integers of matche
lengths we get with the one we want and reports and error if there's a
discrepancy. The function \ty{checkS} checks the slices of slices of
subject IDs.
#+end_export
#+begin_src go <<Testing functions, Pa. \ref{pa:mat}>>=
  func checkM(t *testing.T, get, want []int) {
	  diff := false
	  //<<Determine whether get differs from want, Pa. \ref{pa:mat}>>
	  //<<Respond to difference, Pa. \ref{pa:mat}>>
  }
#+end_src
#+begin_export latex
If we find a difference between the two slices given, we set \ty{diff}
to true and break from the loop.
#+end_export
#+begin_src go <<Determine whether get differs from want, Pa. \ref{pa:mat}>>=
  for i, _ := range get {
	  if get[i] != want[i] {
		  diff = true
		  break
	  }
  }
#+end_src
#+begin_export latex
If the arrays differed, we respond by printing them via the testing
error function.
#+end_export
#+begin_src go <<Respond to difference, Pa. \ref{pa:mat}>>=
  if diff {
	  t.Errorf("\nget:  %v\n" +
		  "want: %v",
		  get, want)
  }
#+end_src
#+begin_export latex
The function to check the subjects is very similar, however now we
want to compare double slices.
#+end_export
#+begin_src go <<Testing functions, Pa. \ref{pa:mat}>>=
  func checkS(t *testing.T, get, want [][]int) {
	  diff := false
	  //<<Determine whether get differs from want IDs, Pa. \ref{pa:mat}>>
	  //<<Respond to difference, Pa. \ref{pa:mat}>>
  }
#+end_src
#+begin_export latex
If we find a difference between the two slices given, we set \ty{diff}
to true and break from the loop.
#+end_export
#+begin_src go <<Determine whether get differs from want IDs, Pa. \ref{pa:mat}>>=
  for i, _ := range get {
	  if slices.Compare(get[i],want[i]) != 0{
		  diff = true
		  break
	  }
  }
#+end_src
#+begin_export latex
We import slices.
#+end_export
#+begin_src go <<Testing imports, Pa. \ref{pa:mat}>>=
"slices"
#+end_src
#+begin_export latex
We come to testing the analysis of the queries' reverse strands. We
construct them, toggle \ty{rev} to true and compare the queries and
subjects.
#+end_export
#+begin_src go <<Test analysis of reverse strand, Pa. \ref{pa:mat}>>=
  //<<Construct reverse queries, Pa. \ref{pa:mat}>>
  //<<Construct wanted reverse results, Pa. \ref{pa:mat}>>
  rev = true
  //<<Compare queries and subjects, Pa. \ref{pa:mat}>>
#+end_src
#+begin_export latex
We construct the reverse queries from the forward sequences used
above.
#+end_export
#+begin_src go <<Construct reverse queries, Pa. \ref{pa:mat}>>=
      queries = [][]byte{
	  []byte("ACTATTATTT"),
	  []byte("AATACTATTT")}
#+end_src
#+begin_export latex
We've already constructed the subjects we want, so we proceed to
constructing the results we want.
#+end_export
#+begin_src go <<Construct wanted reverse results, Pa. \ref{pa:mat}>>=
  wml = [][]int{
	  []int{2,2,1,2,4,3,2,1,0,1},
	  []int{2,4,3,2,1,0,4,3,2,1}}
  wsu = [][][]int{
	  [][]int{{0},{1},{1},{0},{1},
		  {1},{0,1},{0,1},{0,1},{0,1}},
	  [][]int{{0},{1},{1},{0,1},{0,1},
		  {0,1},{1},{0,1},{0,1},{0,1}}}
#+end_src
