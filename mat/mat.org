#+begin_export latex
\section{Implementation}
!Package \ty{mat} implements the matching procedure of \ty{alfy}.

Our outline of \ty{mat} contains hooks for imports and functions.
\bpa{mat}{pa:mat}
#+end_export
#+begin_src go <<mat.go>>=
  package mat
  import (
	  <<Imports, Pa. \ref{pa:mat}>>
  )

  <<Functions, Pa. \ref{pa:mat}>>
#+end_src
#+begin_export latex
\epa

!The function \ty{UpdateMatchLengths} takes as arguments a query
!sequence, the enhanced suffix array (ESA) of a subject sequence, the
!label of that subject sequence, an array of match lengths, an array
!of subject labels, and whether or not the query is a reverse
!strand. It then updates the arrays of match lengths and subject
!labels.

As described in Algorithm~\ref{alg:alf}, we initialize the query
position, $j$, to the leftmost position in the query sequence (line
3). Then we calculate the match lengths in the while loop, before we
interpolate the match lengths.
#+end_export
#+begin_src go <<Functions, Pa. \ref{pa:mat}>>=
  func UpdateMatchLengths(q []byte, s *esa.Esa, i int,
	  ml, su []int, rev bool) {
	  j := 0
	  //<<Calculate match lengths, Pa. \ref{pa:mat}>>
	  //<<Interpolate match lengths, Pa. \ref{pa:mat}>>
  }
#+end_src
#+begin_export latex
We import \ty{esa}.
#+end_export
#+begin_src go <<Imports, Pa. \ref{pa:mat}>>=
  "github.com/evolbioinf/esa"
#+end_src
#+begin_export latex
In the while loop of Algorithm~\ref{alg:alf}, we first determine the
length, $\ell$, of the longest match of the prefix of $q[j...]$ in
$s$. If we are dealing with a reverse strand, we map the position of
this match to the forward strand. Then we check whether we need to
update the match length. Finally, we move the query position, $j$,
just beyond the terminal mismatch.
#+end_export
#+begin_src go <<Calculate match lengths, Pa. \ref{pa:mat}>>=
  m := len(q)
  for j < m {
	  l := s.MatchPref(q[j:]).L
	  p := j
	  //<<Map to forward strand?, Pa. \ref{pa:mat}>>
	  //<<Update match length?, Pa. \ref{pa:mat}>>
	  j += l + 1
  }
#+end_src
#+begin_export latex
If we are analyzing a reverse strand, \ty{p} refers to the position on
that strand, which we map to the forward strand.
#+end_export
#+begin_src go <<Map to forward strand?, Pa. \ref{pa:mat}>>=
  if rev {
	  p = m - p -l
  }
#+end_src
#+begin_export latex
If $\ell$, is greater than $\mbox{ml}[j]$, we update $\mbox{ml}[j]$
and note the label of the current subject sequence, $i$.
#+end_export
#+begin_src go <<Update match length?, Pa. \ref{pa:mat}>>=
  if l > ml[p] {
	  ml[p] = l
	  su[p] = i
  }
#+end_src
#+begin_export latex
We interpolate the match lengths and subject labels according to
Algorithm~\ref{alg:int}.
#+end_export
#+begin_src go <<Interpolate match lengths, Pa. \ref{pa:mat}>>=
  for i := 1; i < len(q); i++ {
	  x := ml[i-1] - 1
	  if x >= ml[i] {
		  ml[i] = x
		  su[i] = su[i-1]
	  }
  }
#+end_src
#+begin_export latex
We've finished writing package \ty{mat}, let's test it.
\section{Testing}
The outline of our testing code contains hooks for imports, functions,
and the testing logic.
#+end_export
#+begin_src go <<mat_test.go>>=
  package mat

  import (
	  //<<Testing imports, Pa. \ref{pa:mat}>>
  )

  //<<Testing functions, Pa. \ref{pa:mat}>>
  func TestMat(t *testing.T) {
	  //<<Testing, Pa. \ref{pa:mat}>>
  }
#+end_src
#+begin_export latex
We import \ty{testing}.
#+end_export
#+begin_src go <<Testing imports, Pa. \ref{pa:mat}>>=
  "testing"
#+end_src
#+begin_export latex
We test the analysis of forward and reverse strands separately.
#+end_export
#+begin_src go <<Testing, Pa. \ref{pa:mat}>>=
  //<<Test analysis of forward strand, Pa. \ref{pa:mat}>>
  //<<Test analysis of reverse strand, Pa. \ref{pa:mat}>>
#+end_src
#+begin_export latex
We construct the forward queries and subjects and the corresponding
expected results. The difference between the analysis of forward and
reverse strands is just a boolean variable, \ty{rev}. We set that to
false before we compare queries and subjects to do the actual testing.
#+end_export
#+begin_src go <<Test analysis of forward strand, Pa. \ref{pa:mat}>>=
  //<<Construct forward queries, Pa. \ref{pa:mat}>>
  //<<Construct forward subjects, Pa. \ref{pa:mat}>>
  //<<Construct wanted results, Pa. \ref{pa:mat}>>
  rev := false
  //<<Compare queries and subjects, Pa. \ref{pa:mat}>>
#+end_src
#+begin_export latex
We take the queries used in Chapter~\ref{ch:int}.
#+end_export
#+begin_src go <<Construct forward queries, Pa. \ref{pa:mat}>>=
  queries := [][]byte{
	  []byte("AAATAATAGT"),
	  []byte("AAATAGTATT")}
#+end_src
#+begin_export latex
We also take the subjects from Chapter~\ref{ch:int}.
#+end_export
#+begin_src go <<Construct forward subjects, Pa. \ref{pa:mat}>>=
  subjects := [][]byte{
	  []byte("AATTTAAATT"),
	  []byte("TAATAATATT")}
#+end_src
#+begin_export latex
We construct the match lengths and the subject labels we want.
#+end_export
#+begin_src go <<Construct wanted results, Pa. \ref{pa:mat}>>=
  wml := [][]int{
	  []int{4,3,2,5,4,3,2,1,0,1},
	  []int{4,3,2,2,1,0,4,3,2,1}}
  wsu := [][]int{
	  []int{0,0,0,1,1,1,1,1,1,0},
	  []int{0,0,0,1,1,1,1,1,1,1}}
#+end_src
#+begin_export latex
For each query we prepare an array of match lengths and an array of
subject labels. Then we iterate over the subjects and check the
match lengths and subject labels we get from that iteration.
#+end_export
#+begin_src go <<Compare queries and subjects, Pa. \ref{pa:mat}>>=
  for i, q := range queries {
	  //<<Prepare $\mbox{ml}$ and $\mbox{su}$, Pa. \ref{pa:mat}>>
	  //<<Iterate over subjects, Pa. \ref{pa:mat}>>
	  //<<Check $\mbox{ml}$ and $\mbox{su}$, Pa. \ref{pa:mat}>>
  }
#+end_src
#+begin_export latex
We create a new pair of arrays to hold the match lengths and the
subject labels for each query position. Since zero is a legitimate
value for match lengths and subject labels, we initialize both arrays
to -1. This allows us to check for gaps in our analysis.
#+end_export
#+begin_src go <<Prepare $\mbox{ml}$ and $\mbox{su}$, Pa. \ref{pa:mat}>>=
  n := len(q)
  ml := make([]int, n)
  su := make([]int, n)
  for j := 0; j < n; j++ {
    ml[j] = -1
    su[j] = -1
  }
#+end_src
#+begin_export latex
We convert each subject to its enhanced suffix array and update the
match lengths accordingly.
#+end_export
#+begin_src go <<Iterate over subjects, Pa. \ref{pa:mat}>>=
  for j, subject := range subjects {
	  s := esa.MakeEsa(subject)
	  UpdateMatchLengths(q, s, j, ml, su, rev)
  }
#+end_src
#+begin_export latex
We import \ty{esa}.
#+end_export
#+begin_src go <<Testing imports, Pa. \ref{pa:mat}>>=
  "github.com/evolbioinf/esa"
#+end_src
#+begin_export latex
We check the updated arrays by calling the function \ty{check}.
#+end_export
#+begin_src go <<Check $\mbox{ml}$ and $\mbox{su}$, Pa. \ref{pa:mat}>>=
  check(t, ml, wml[i])
  check(t, su, wsu[i])
#+end_src
#+begin_export latex
The function \ty{check} compares the array of integers we get with the
one we want and reports and error if there's a discrepancy.
#+end_export
#+begin_src go <<Testing functions, Pa. \ref{pa:mat}>>=
  func check(t *testing.T, get, want []int) {
	  diff := false
	  //<<Determine whether get differs from want, Pa. \ref{pa:mat}>>
	  //<<Respond to difference, Pa. \ref{pa:mat}>>
  }
#+end_src
#+begin_export latex
If we find a difference between the two slices given, we set \ty{diff}
to true and break from the loop.
#+end_export
#+begin_src go <<Determine whether get differs from want, Pa. \ref{pa:mat}>>=
  for i, _ := range get {
	  if get[i] != want[i] {
		  diff = true
		  break
	  }
  }
#+end_src
#+begin_export latex
If the arrays differed, we respond by printing them via the testing
error function.
#+end_export
#+begin_src go <<Respond to difference, Pa. \ref{pa:mat}>>=
  if diff {
	  t.Errorf("\nget:  %v\n" +
		  "want: %v",
		  get, want)
  }
#+end_src
#+begin_export latex
We come to testing the analysis of the queries' reverse strands. We
construct them, toggle \ty{rev} to true and compare the queries and
subjects.
#+end_export
#+begin_src go <<Test analysis of reverse strand, Pa. \ref{pa:mat}>>=
  //<<Construct reverse queries, Pa. \ref{pa:mat}>>
  //<<Construct wanted reverse results, Pa. \ref{pa:mat}>>
  rev = true
  //<<Compare queries and subjects, Pa. \ref{pa:mat}>>
#+end_src
#+begin_export latex
We construct the reverse queries from the forward sequences used
above.
#+end_export
#+begin_src go <<Construct reverse queries, Pa. \ref{pa:mat}>>=
  queries = [][]byte{
	   []byte("ACTATTATTT"),
	   []byte("AATACTATTT")}
#+end_src
#+begin_export latex
We've already constructed the subjects we want, so we proceed to
constructing the results we want.
#+end_export
#+begin_src go <<Construct wanted reverse results, Pa. \ref{pa:mat}>>=
  wml = [][]int{
	  []int{2,2,1,2,4,3,2,1,0,1},
	  []int{2,4,3,2,1,0,4,3,2,1}}
  wsu = [][]int{
	  []int{0,1,1,0,1,1,1,1,1,0},
	  []int{0,1,1,1,1,1,1,1,1,1}}
#+end_src
